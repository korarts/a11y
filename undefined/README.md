# 참조 링크

## 🐱‍🏍 1장. Getting Start HTML5

### Epilogue > Quiz

**Q1. HTML5의 특징을 설명한 것 중 틀린 것은?**

1. HIML5는 HTML버전 5번째 개정안으로 현재 웹 페이지를 만들때 일반적으로 사용되는 것은 HTML5이고, 차세대 웹 환경에 맞게 새로운 사양을 검토하는 것이 HTML5이다.
2. HTML는 지금까지의 HTML4와 같은 HTML문서를 만드는 기능이 향상된느 것 외에도, 웹 응용 프로그램을 개발하기 위한 다양한 사양이 새롭게 포함되어 있다.
3. 지금까지 플러그인 등의 HTML 이외의 기술을 병행하지 않으면 실현 될 수 없었던 기능의 일부가 표준 HTML5 및 Javascript에서 비교적 간단하게 실현할 수 있게 제공된다.
4. HTML5의 목적은 HTML요소로 구조를 만들고 HTML문서를 구현하는 것이다.

정답 : 4번\
해설 : HTML4와 XHTML1의 목적이 HTML 요소로 구조를 만들고 HTML 문서를 구현하는 것이다.

**Q2. HTML5의 장점이 아닌 것은?**

1. 마크업(Markup) 용량이 줄어 로딩 시간이 빨라진다.
2. 콘텐츠와 문서모양이 분리 되어 문서 유지 보수가 쉬워진다.
3. 상호호환성(Cross Browsing)으로 웹브라우저의 사용이 편리해진다.
4. 스타일과 구조 및 기능이 함께 되어있어 개발 시간이 단축된다

정답 : 4번\
해설 : 스타일, 구조, 기능이 모두 분리되어 문서 유지 보수가 쉽고 간결해 진다.

**Q3. HTML5에서 종료요소를 사용하지 않는 요소가 아닌 것은?**

1. area, base, br, col, command, embed
2. html, head, body, colgroup, tbody
3. hr, img, input, keygen, link
4. meta, param, source, track, wbr

정답 : 2번\
해설 : html, head, body, colgroup, tbody는 완전히 생략해도 되는 요소이다.

***

## 🐱‍🏍 02장. 레이아웃 구조를 세우는 HTML5 요소

### 🎯 Prologue > Pre-quiz

**Q1. 시맨틱 마크업(Semantic Markup)이란 의미론적으로 HTML로 직역되며, 표현에 대한 요소를 사용하여 문서에 적용되는 문서화를 말한다.**

1. 예, 2. 아니오

정답 : 아니오\
해설 : 의미론적인 HTML로 직역되며, 표현에 대한 요소를 사용하기보다 **내용에 맞는 요소를 사용**하며 웹 표준에 맞게 적용되는 문서화를 말합니다.

**Q2. 문서의 구조화란 HTML5에서 header, nav, section, article, footer 등의 구조화 요소가 추가되어 적용하는 것을 말한다.**

1. 예, 2. 아니오

정답 : 아니오\
해설 : 문서의 구조화란 HTML5에서 header, nav, section, article, footer 등의 **구조화 요소가 추가**되어 브라우저나 검색 엔진에 명확하게 문서 구조를 전달할 수 있도록 합니다.

**Q3. `<video>` 요소는 비디오를 재생하기 위한 요소로 설치된 플러그인을 사용하여야 한다.**

1. 예, 2. 아니오

### 정답 : 아니오 해설 : `<video>` 요소는 비디오를 재생하기 위한 요소이며, **플러그인을 사용하지 않고도 비디오를 재생**을 할 수 있습니다.

### Epilogue > Quiz

**Q1. 문서 구조화 요소에 대한 설명 중 틀린 것은?**

1. `<article>`요소는 독립적인 내용을 나타내는 요소이다.
2. `<footer>`요소는 가장 가까운 곳의 선행하는 섹션의 푸터를 의미한다.
3. `<nav>`요소는 네비게이션을 위해 구성된 섹션을 나타낸다.
4. `<section>`요소는 내용의 소개 및 탐색 정보 등의 정보를 나타낸다.

정답 : 4번\
해설 : `<section>`은 문서의 구조를 나타내며 내용소개 및 탐색정보는 `<header>`요소가 나타낸다.

**Q2. `<embed>` 요소 설명 중 틀린 것은 ?**

1. `<embed>`는 Flash , 동영상, 오디오등 브라우저의 외부 콘텐츠를 이용하기 위한 요소이다.
2. 동영상(MP4 형식)파일 같은 비 HTML 외부 컨텐츠와 인터랙티브(쌍방향적)인 내용을 포함 할 때 사용된다.
3. `<embed>`요소를 사용하여 포함된 내용은 플러그인이 필요 없이 실행된다.
4. `<embed>` 지정하는 경우, 시작 요소만 선언하며 "name", "align", "hspace", "vspace"의 속성은 사용되지 않는다

정답 : 3번\
해설 : `<embed>`요소를 사용하여 포함된 내용은 플러그인을 통해 재생되며 선언 시 종료 요소가 없다.

**Q3. 문서의 구조에서 네이게이터를 다음과 같이 하려고 한다. 빈칸에 순서대로 들어갈 요소는 무엇인가?**

1. `<section></section>`
2. `<embed></embed>`
3. `<header></header>`
4. `<nav></nav>`

```html
<ul>
    <li><a href="http://www.daum.net">다음으로</a></li>
    <li><a href="http://vwww.naver.com">네이버로</a></li>
</ul>
```

정답 : 4번\
해설 : `<nav>`요소는 네비게이션을 위해 구성된 섹션을 나타낸다.

***

## 🐱‍🏍 03장. 쉽고 강력한 HTML5 웹폼

### 🎯 Prologue > Pre-quiz

**Q1. HTML5에서는 웹 페이지에 표현만을 강조한 이전 버전의 요소들은 사용하지 않는다.**

1. 예, 2. 아니오

정답 : 예\
해설 : HTML5에서는 웹 페이지에 문자를 표현했던 이전 버전의 요소들(basefont, big, blink, c enter, font, marquee, spacer, strike, tt, u) 등은 없어지고 CSS로 그 기능을 대신하도록 표준화시켰습니다.

**Q2. `<form>`요소에서 사용된 양식 폼(button, checkbox, file, hidden, image, password, radio, reset, submit, text)은 웹 페이지에서 자료의 입력이나 선택 사용자가 입력한 정보를 서버로 보내어 처리하도록 해주는 기능을 가진다.**

1. 예, 2. 아니오

정답 : 예\
해설 : `<form>`요소에서 사용된 양식 폼(button, checkbox, file, hidden, image, password, radio, reset, submit, text)은 웹 페이지에서 자료의 입력이나 선택 등 사용자와의 상호작용을 가능하게 해주는 UI기술로 **사용자가 입력한 정보를 서버로 보내어 처리하도록 해주는 기능**을 가집니다.

**Q3. `<meter>`요소는 파일의 다운로드 등과 같이 진행 상태를 표시할 때 사용된다.**

1. 예, 2. 아니오

정답 : 예\
해설 : `<meter>`요소는 정해진 범위 내에서의 측정 값을 나타내는 요소로 **디스크 사용량 및 투표 수 등의 값을 표시**할 때 사용합니다.

### Epilogue > Quiz

**Q1. `<meter>`요소의 설명 중 틀린 것은?**

1. `<meter>`요소는 정해진 범위 내에서의 측정 값을 나타내는 요소로 디스크 사용량 및 투표 수 등의 값을 표시할 때 사용한다.
2. 진행률을 표시하는 등의 사용 목적으로는 적절하지 않으며 표시하고자 할 때는 `<progress>` 요소를 사용한다
3. 측정 대상의 범위가 명확하지 않은 경우, 예를 들면 어떤 물건의 무게와 높이를 나타내는 등의 경우에도 사용하지 않는다.
4. max속성은 작업을 완료하는 데 필요한 전체 용량을 지정하며 값은 0이상이어야 한다.

정답 : 4번\
해설 : max 속성은 측정 범위의 최대값을 지정하며 지정하는 값은 "min"속성 값 이상이어야 하고 지정하지 않으면 기본값이 1이 된다.

**Q2. `<keygen>`요소의 설명 중 틀린 것은?**

1. `<keygen>` 요소의 목적은 사용자를 인증할 수 있는 안전한 방법을 제공하는 것이다.
2. 폼이 submit될 때 `<keygen>` 요소는 private(개인), public(공개)키인 한 쌍(key-pair generator)의 키로 생성한다.
3. private(개인키)으로 생성되는 키는 로컬에 저장되고 public(공개형)으로 생성되는 키는 서버로 전송된다.
4. public(공개)는 사용자를 인증하기 위한 서버 인증서를 생성하는데 사용된다.

정답 : 4번\
해설 : public(공개)는 사용자를 인증하기 위해 클라이언트 인증서를 생성하는 데 사용된다.

**Q3. 다음 요소와 기능이 맞게 설명된 것은 무엇인가?**

1. datetime : 날짜와 시간(년, 월, 일, 시, 분, 초, 초 분수)이 없는 시간대 정보와 함께 ISO 8601에 따라 인코딩한다.
2. date : 일년에 구성된 날짜와 달을 ISO 8601에 따라 인코딩한다.
3. time: 시간(시, 분, 초, 초 분수)는 ISO 8601에 따라 인코딩한다
4. week : 날짜와 시간(년, 월, 일, 시, 분, 초, 초 분수)는 세계 협정시에 시간대 세트 ISO 86071에 따라 인코딩한다

정답 : 3번\
해설 : 1번은 'datetime-local'에 대한 설명이고, 2.번은 month 대한 설명이며, 4번은 datetime에 대한 설명이다.

***

## 🐱‍🏍 04장. Canvas Painting

### 🎯 Prologue > Pre-quiz

**Q1. 캔버스란 웹에서 즉시 모드 (immediate mode)로 2차원 그래픽을 그리기 위한 API와 Canvas내 각종 객체인 점, 선, 도형, 이미지 생성 등의 각종 효과를 주는 기능에 대한 API를 말한다.**

1. 예 2. 아니오

정답 : 예\
해설 : 웹에서 즉시 모드(immediate mode)로 2차원 그래픽을 그리기 위한 API와 Canvas내 각종 객체인 점, 선, 도형, 이미지 생성 등의 각종 효과를 주는 기능에 대한 API를 말하며 브라우저에 표시되는 페이지의 좌표 내에 **width, heaight라는 속성을 지정**해서 어떤 그래픽을 표현하기 위한 기본적인 공간을 만들어 사용합니다.

**Q2. 캔버스에는 20가 제공하는 메소드들을 이용해서 선, 사각형, 원 등의 여러 가지 도형을 그려 낼 수 있으며 메소드만을 통해 색상과 두께 등을 조절할 수 있다.**

1. 예 2. 아니오

정답 : 아니오\
해설 : 캔버스에는 2D가 제공하는 ALES 이용해서 선, 사각형, 원 등의 **여러 가지 도형**을 그려낼 수 있으며 속성을 통해 **색상과 두께 등을 조절**할 수 있습니다.

**Q3. 도형을 그려내는 속성은 IDL(Interface description Language)로만 제공된다.**

1. 예 2. 아니오

정답 : 아니오\
해설 : 도형을 그릴 때 공통적으로 사용되는 속성은 \*\*IDL(Interface description language)\*\*과 **도형의 두께 및 색상 등을 나타내는 속성**들로 제공된다.

### Epilogue > Quiz

**Q1 다음 중 캔버스에 대한 설명이 아닌 것은?**

1. 2D 컨텍스트의 도헝들은 http://www.w3.org/TR/2dcontext2/의 API를 참조해서 메소드들을 호출하여 사용한다.
2. 선, 원, 사각형 등을 그릴 수 있으며 회전, 그레디언트 그래픽 등을 사용할 수 있는 메소드들을 제공한다.
3. 캔버스는 비트맵 이미지 요소를 지원하지 않는다.
4. 웹에서 즉시모드(immediate mode)로 2차원 그래픽을 그리기 위한 API와 Canvas내 각종 객체인 점, 선, 도형, 이미지 생성 등의 각종 효과를 주는 기능에 대한 API를 말한다.

정답 : 3번 해설 : `<canvas>` 요소는 내부에 비트맵 이미지 요소를 넣을 수 있고, 비트맵과 벡터를 지원한다.

**Q2 다음 중 캔버스 특징을 설명한 것이 아닌 것은?**

1. 정의된 웹 페이지에 Canvas의 각종 객체를 자바스크립트를 이용해서 회전, 변환, 그레디언트 그래픽이나 게임과 같이 동적인 비트맵 이미지로 개발할 수 있다.
2. 서버에서 이미지를 자유롭게 생성할 수 있으며 픽셀 값 지정 및 변경을 쉽게 할 수 있다.
3. 웹페이지 상에 있는 그래픽 영역을 구현하여 도형을 생성한 후 상태를 저장 및 복구할 수 있다.
4. 캔버스는 2D와 SpiderGL, SceneJs, Three.js와 같이 3D를 사용하는 라이브러리 등, 한 개 이상의 인터페이스를 지원하여 동일한 요소를 가지고 다른 인터페이스로 그려 낼수 있다.

정답 : 2번\
해설 : 클라이언트에서 이미지를 자유롭게 생성할 수 있으며 픽셀 값 지정 및 변경을 쉽게 할 수 있습니다.

**Q3. 다음 중 도형을 그릴 때 공통적으로 사용되는 속성인 IDL(Interface Description language)중 맵핑이 잘못된 것은?**

1. strokeStyle : 도형의 외곽선 색상을 지정
2. fillstyle : 도형의 색깔을 지정
3. lineWidth : 도형의 두께를 지정
4. lineCap : 도형의 그림자를 지정

정답 : 4번\
해설 : lineCap은 라인 끝 형태(butt, round, square)중 하나를 지정해서 사용되는 속성입니다.

***

## 🐱‍🏍 05장. Canvas에서 다이나믹 애니메이션 만들기

### 🎯 Prologue > Pre-quiz

**Q1. 구현되는 텍스트는 글자의 크기, 글꼴, 정렬을 지장하는 속성과 넓이 외곽선 등을 처리하는 메소드로 구성된다.**

1. 예 2. 아니오

정답 : 예\
캔버스에 구현되는 텍스트는 글자의 크기, 글꼴, 정렬을 지정하는 속성과 지정된 색으로 글자를 채우거나 외곽션 처리 및 주어진 문자열의 픽셀 넓이를 반환하는 메소드들로 구성되어 있습니다.

**Q2. 캔버스의 이미지 표현은 이미지 파일을 `<img>` 요소에 접목해서 사용하는 것을 말한다.**

1. 예 2. 아니오

정답 : 아니오\
캔버스에서 이미지를 표현하는 것은 캔버스에 이미지를 나타나는 것을 말하며, 이미지를 객체화해서 사용되는 메소드들을 제공하고 있습니다.

**Q3. 캔버스에서는 다이나믹한 이미지를 연동하기 위해 회전, 크기, 위치 변경, 각도 변경 등을 구현하는 메소드들을 지원한다.**

1. 예 2. 아니오

정답 : 예\
생성된 이미지는 애니메이션을 연동하는 메소드에 따라 회전, 늘임과 줄임, 크기, 위치 변경 등 다양한 표현식으로 사용됩니다.

### Epilogue > Quiz

**Q1 다음은 그림자를 표현하는 속성값과 설명이다. 잘못 설명된 것은 무엇인가?**

1. ctx.shadowBlur=10; 도형의 그림자에 blurring 효과를 지정하고 숫자가 클수록 진하게 나타난다.
2. ctx.shadowOffsetX=20; x좌표의 20정도에 수평방향으로 그림자가 표시된다.
3. ctx.shadowOffsetY=20; y좌표의 20정도의 수직 방향으로 그림자가 표시된다.
4. ctx.shadowColor="pink"; 그림자의 색상은 핑크로 지정한다.

정답 : 1번\
shadowBlur 도형의 그림자에 blurring 효과를 지정한다. 기본은 0이고 숫자가 클수록 흐리게 나타난다.

**Q2 캔버스의 이미지 설명으로 잘못된 것은?**

1. 캔버스에서 이미지를 표현하는 것은 캔버스에 이미지를 나타내는 것을 말한다.
2. 캔버스에서는 이미지를 `<img>` 요소를 이용해서 맵핑한다.
3. 생성된 이미지는 애니메이션을 연동하는 메소드에 따라 회전, 늘임과 줄임 등 다양한 표현식으로 사용된다.
4. 이미지를 표현하는 속성으로는 이미지의 넓이를 지정하는 width, 이미지의 높이를 지정하는 height, 이미지가 가진 픽셀을 RGBA 순서인 배열로 관리되는 data 속성이 있다.

정답 : 2번\
이미지를 객체화해서 표현하며 캔버스에서는 제공되는 메소드들을 사용한다.

**Q3 scale(0.5, 0.5) 메소드를 선언하고 이미지를 드로우한 경우 올바른 결과는 무엇인가?**

1. 원본 이미지가 가로 세로 방향으로 50%, 50% 축소된 이미지가 그려진다.
2. 원본 이미지가 가로 세로 방향으로 50%, 50% 기울기로 그려진다.
3. 원본 이미지가 가로 세로 방향으로 0.5%, 0.5% 축소된 이미지가 그려진다
4. 원본 이미지가 가로 세로 방향으로 50%, 50% 좌표가 이동된 상태의 이미지가 그려진다.

정답 : 1번\
scale(scalewidth, scaleheight) 메소드는 객체 이미지 크기를 변화시키는 기능을 가진 메소드로 매개인자값을 각각 1로 주면 100%, 2로 주면 200% 크기로 확대되고 0.5를 주면 50%로 축소되는 객체를 표시하게 된다.

***

## 🐱‍🏍 06장. 브라우저만의 표준기능만으로 DnD(Drag & Drop)

### 🎯 Prologue > Pre-quiz

**Q1. HTML5에서 Drag & Drop은 외부 라이브러리나 jQuery 플러그의 API를 이용해서만 연동된다.**

1. 예 2. 아니오

정답 : 아니오\
해설 : HTML5에서 Drag & Drop은 외부 라이브러리나 jQuery 플러그인에 의존하지 않고 브라우저의 표준 기능만으로 구현하도록 "Drag & Drop API"를 정의한 것을 말한다.

**Q2. dataTransfer 개체는 드래그와 드롭 시에 객체간에 필요한 데이터를 저장하고 호출하는 기능을 가진다.**

1. 예 2. 아니오

정답 : 예\
해설 : dataTransfer 개체는 드롭시 데이터를 제거하거나 데이터를 대상에 전달할 때에 Drag & Drop을 실현합니다.

**Q3. DropEffect는 드롭 상호 작용을 인식하는 요소의 작업유형을 설정한다.**

1. 예 2. 아니오

정답 : 아니오\
해설 : DropEffect는 끌고 있는 마우스 아이콘에 드롭 결과 유형을 복사, 링크, 이동 등으로 설정하는 속성입니다.

### Epilogue > Quiz

오늘 배운 내용을 퀴즈를 통해 정리해 보세요

**Q1. 다음과 같은 코드를 지정해서 드래그를 시작하려고 한다.** \_\_\_\_\_\_에 차례로 들어갈 코드를 정확하게 나열한 것은?

```html
<img ______ id="imglink" ______="drag(this, event);" src="img_a.ipg" alt="">
```

1. draggable="true", ondragstart
2. ondragstart, draggable="true"
3. ondratdrop, draggable="none"
4. draggable="false", ondragstart

정답 : 1번\
해설 : 이미지를 드래그 하려고 하기 때문에 속성을 draggable=true로 명시하고 드래그를 시작하려는 이벤트 메소드를 ondragstart 속성에 대입합니다.

**Q2. ondragover="onDragOver(event)"를 지정 했을 때 다음 코드의 설명이 틀린 것은 무엇인가?**

```js
function onDragOver(e){
	e.dataTransfer.dropEffect="move";
	e.preventDefault();
}
```

1. e.dataTransfer.dropEffect="move"는 Drop할 때 효과를 나타낸다.
2. e.preventDefault()는 ondragover 이벤트의 기본 처리를 취소한다.
3. e.preventDefault()는 메소드를 호출하지 않거나 false를 반환하지 않으면 Drop 이벤트를 허용하지 않는다.
4. onDragOver(e)는 드래그된 요소가 드롭 대상 위치에서 벗어나서 이동할 때 발생한다.

정답 : 4번\
해설 : onDragOver(e)는 드래그 된 요소가 드롭 대상 위치로 옮겨져 지나고 있을 때 발생합니다.

**Q3. 다음 이벤트 정의된 기능이 잘못 설명된 것은?**

1. dragstart : 요소를 드래그하고자 하는 순간 발생한다.
2. drag : 드래그를 하는 마우스가 움직일 때 발생한다.
3. dragenter : 드래그 된 요소가 드롭 대상 위치를 선택할 때 발생한다.
4. dragover : 드래그 된 요소가 드롭 대상 위치로 옮겨져 지나고 있을 때 발생한다.

정답 : 3번\
해설 : dragenter는 드래그 된 요소가 드롭 대상 위치로 옮겨져 지나고 있을 때 발생합니다.

***

## 🐱‍🏍 07장. 로컬에서 관리되는 File API

### 🎯 Prologue > Pre-quiz

**Q1. File API란 웹 어플리케이션이 로컬 파일의 내용에 접근할 수 있도록 하는 API 를 말한다.**

1. 예 2. 아니오

정답 : 아니오\
해설 Fil e API란 웹 어플리케이션이 로컬 파일의 내용에 접근할 수 있도록 하는 API를 말하며, 로컬에 저장되어 있는 파일의 속성과 내용을 검색하는 API를 말합니다.

**Q2. 로컬에서 관리할 수 있는 파일을 사용자의 파일 시스템에서 모두 접근할 수 있는 것은 아니다.**

1. 예 2. 아니오

정답 : 아니오\
로컬에 접근 가능한 파일은 Drag & Drop이나, 파일 선택 폼(type 속성에 "file" 을 지정한 input 요소)을 이용하여 사용자가 직접 선택한 파일에 한정되어 있습니다.

**Q3. fileWriter의 개체는 장치파일 시스템(UTF-8 인코딩)에 파일을 작성하는 방법으로 사용한다.**

1. 예 2. 아니오

정답 : 예\
fileWriter의 개체는 장치파일 시스템(UTF-8 인코딩)에 파일을 작성하는 방법으로 사용자는 파일쓰기, 오류 및 중지 등의 이벤트를 수신하기 위해 자신의 이벤트 리스너를 등록해서 사용합니다.

### Epilogue > Quiz

Q1. 윈도우에 생성된 디렉토리를 삭제 하려면 \_\_\_\_\_에 순서적으로 들어가야 하는 코드는 무엇인가?

```js
function __(A)__(entry) {
	console.log("Removal succeeded");
}
function __(B)__(error) {
	alert('Error removing directory:' + error.code);
}
entry.__(C)__ (__(D)__, __(E)__):
```

1. success(A) -> fail(B) -> remove(C) -> success(D)-> fail(E)
2. success(A)-> success(B) -> remove(C) -> success(D)-> remove(E)
3. success(A) -> fail(B) -> remove(C) -> fail(D) -> success(E)
4. success(A) -> success(B) -> remove(C) -> success(D)-> remove(E)

정답 : 1번\
해설 : DirectoryEntry.remove(successCallback, errorCallback)의 원형을 가진 메서드로 지정된 디렉토리에 하위가 비워 있어야 하며 파일 시스템의 루트 디렉토리를 삭제합니다.

Q2. DirectoryEntry의 속성과 뜻을 다르게 설명 한 것은?

1. isFile : 파일의 여부를 true/false로 리턴한다.
2. isDirectory : 디렉토리의 여부를 true/false로 리턴한다.
3. name : 디렉토리의 이름을 리턴한다.
4. fullpath : 루트에서의 전체 상대 경로를 리턴 하거나 지정한다.

정답 : 4번\
해설 : fullPath는 루트에서의 전체 경로를 리턴 하거나 지정하는 것 입니다.

File의 속성이 아닌 것은?

1. Name
2. toURL
3. fullPath
4. lastModifiedDate

정답 : 2번\
해설 : toURL은 파일 또는 디렉토리의 URL를 리턴 하는 메소드로 FileEntry, Directoryentry가 제공하는 메소드입니다.

***

## 🐱‍🏍 08장. Web Message 표준 Communication API

### 🎯 Prologue > Pre-quiz

**Q1. Communication API란 브라우저 제작사와 표준화 단체가 만든 API로 페이지 간의 값전달, 다른 도메인간의 문자열 전달 등을 할 수 있는 기능을 말한다.**

정답 : 예\
해설 : Communication API 란 브라우저 제작사와 표준화 단체가 만든 API로 기존에 불편했던 다른 도메인과의 통신, 다른 웹 페이지, 탭 페이지간의 메시지 및 문서를 이용해서 보안 통신이 가능하도록 정의한 web Messaging 표준을 말합니다.

**Q2. 채널 메시징(Channel Messaging)은 크로스 도먼트처럼 데이터 송수신을 Window 단위로 실행한다.**

정답 : 아니오\
해설 : 채널 메시징(Channel Messaging)은 크로스 도큐먼트처럼 데이터 송수신을 Window 단위로 실시하는 것이 아니라 여러 개의 생성이 가능한 메시지 채널 객체를 사용하여 수행하는 것을 말합니다.

**Q3. 채널 메시징을 이용해서 다른 문서간의 데이터를 주고 받을 때는 MessagePort의 객체도 배열형태로 지정되어 추가로 전달된다.**

정답 : 예 해설 : 채널 메시징을 이용해서 다른 문서간의 데이터를 주고 받을 때는 통신을 할 Message Channel 개체의 port1, port2 중 하나는 메시지를 전달하는 송신 역할을 해야 하며 MessagePort의 객체도 배열형태로 지정되어 추가로 전달됩니다.

Epilogue Quiz

**Q1. 다음 중 크로스 도큐멘트 메시징의 특징이 아닌 것은?**

1. 서로 다른 두 개 이상의 웹 페이지가 메세지를 주고 받을 수 있다.
2. 메세지는 동기화로 송/수신 된다.
3. 메세지가 송/수신 될때 웹 페이지의 Ul에 전혀 영향을 주지 않는다.
4. 서 로 다른 도메인간의 송/수신도 가능하다.

정답 : 2번 해설 : 메세지는 비동기로 송/수신된다.

**Q2. 채널 메시징의 설명 중 틀린 것은 무엇인가?**

1. 채널 메시징(Channel Messaging)은 여러 개의 생성이 가능한 메시지 채널 객체를 사용하여 수행하는 것을 말한다.
2. 채널 메시징을 사용하면 동시에 여러 통신 채널을 사용하여 M:N 통신을 할 수 있다.
3. 채널 메시지 객체는 하나의 메시지에 두 개의 포트가 존재하며 각각 메시지 수신된 이벤트 핸들러와 단말기로 값을 전달하는 역할을 하게 된다.
4. 수신 측 Window의 postmessage( ) Method를 호출하고 수신하는 곳에서는 자신의 window에 대해 onmessage Event Handler를 지정하여 사용한다.

정답 : 4번 해설 : 수신 측 Windows의 postMessage( ) Method를 호출하고 수신하는 곳에서는 자신의 windowo에 대해 onmessage Event Handlers 지정하여 사용하는 방법은 크로스 도큐먼트 메시징에 대한 방법이다.

***

## 🐱‍🏍 09장. Application Cache

### 🎯 Prologue > Pre-quiz

**Q1. Web Application Cache란 HTML5에서 제공하는 기능으로 오프라인에서 웹을 사용할 수 있도록 구현할 수 있다.**

1. 예, 2. 아니오

정답 : 예\
해설 : Web Application Cache란 HTML5에서 제공하는 기능으로 오프라인에서 웹을 사용할 수 있도록 제공된 API입니다.

**Q2. 응용 프로그램 캐시를 사용하면 HTML 및 Javascript, 스타일 시트, 이미지, 사운드, 동영상 등의 "Web 응용 프로그램의 동작에 필요한 리소스 파일"이 서버에 저장되게 된다.**

1. 예, 2. 아니오

정답 : 아니오\
해설 : 응용 프로그램 캐시를 사용하면 HTML 및 JavaScript, 스타일 시트, 이미지, 사운드, 동영상 등의 "Web 응응 프로그램의 동작에 필요한 리소스 파일"이 로컬에 저장되게 합니다.

**Q3. 응용 프로그램 캐시를 사용하는 경우 표시 할 HTML 파일과는 별도로 매니페스트(Manifest) 파일을 작성해야 한다.**

1. 예, 2. 아니오

정답 : 예\
해설 : 매니페스트(Manifest) 파일은 간단한 text 파일로 브라우저에게 캐시가 된다고 알려주는 기능을 하며 응용 프로그램 캐시를 사용하는 경우 표시할 HTML 파일과는 별도로 매니페스트(Manifest) 파일을 작성합니다.

### Epilogue > Quiz

**Q1. 다음 Application Cache를 사용하게 되면 좋은 점이 아닌 것은?**

1. offline 브라우징 :사용자들은 offline중에도 application을 사용할 수 있다.
2. speed : 캐시된 리소스를 불러오는 것이 시간적으로 단축된다.
3. 서버 부하 감소 : 브라우저는 단지 바뀐 부분만 서버로부터 받기만 하면 되기 때문에 서버의 기능 향상이 원활하게 된다.
4. 실시간 업데이트 : 캐시를 사용하게 되면 데이터가 서버에 저장되며 서버와 원활하게 통신이 이루어지기 때문에 실시간 업데이트가 신속하게 이루어진다.

정답 : 4번\
해설 : application cache 오프라인 시에 웹을 사용할 수 있는 기능이기 때문에 데이터가 로컬 캐시에 저장이 되어 실시간 업데이트가 실시간으로 신속하게 이루어지지 않는다.

**Q2. Manifest 파일에 적용되는 섹션이 아닌 것은?**

1. CACHE 섹션
2. FALLBACK 섹션
3. ERROR 섹션
4. NETWORK 섹션

정답 : 3번\
해설 : Manifest 파일에 적용되는 세가지로 CACHE, FALLBACK, NETWORK 섹션이 있다.

**Q3. 어플리케이션의 캐시가 지워질 경우가 아닌 것은?**

1. 브라우저 캐쉬가 reload되는 경우
2. Manifest 파일이 수정된 경우
3. Application cache가 프로그래밍적으로 업데이트 될 경우
4. 브라우저가 Reload 될 경우

정답 : 4번\
해설 : 한번 캐시된 파일은 브라우저가 reload 되더라도 사용자들에게는 캐시된 버전이 계속 보여지게 됩니다.

***

## 🐱‍🏍 10장. 브라우저의 저장소 Web Storage

### 🎯 Prologue > Pre-quiz

**Q1. HTML5는 쿠키 대신 데이터 저장 방식으로 "Web Storage"라는 기능을 사용한다.**

1. 예 2. 아니오

정답 : 예\
해설 : Web Storage는 브라우저 측에서 Key-Value 형식으로 데이터를 저장하는 기능으로, 현재 인터넷을 둘러싼 환경에 대응한 "쿠키의 후속 기술"이라고 할 수 있습니다.

**Q2. 세션 스토리지는 웹 세션에서 유효한 스토리지로 페이지마다 탭이 열려있는 동안, Web 어플리케이션 이용에 관한 데이터를 각각의 단위로 저장한다.**

1. 예 2. 아니오

정답 : 예\
해설 : 웹 세션에서 유효한 스토리지로 페이지마다 탭이 열려있는 동안, Web 어플리케이션 이용에 관한 데이터를 각각의 단위로 저장하고 페이지 또는 탭을 닫으면 데이터가 사라집니다.

**Q3. 도메인이 같으면 페이지나 탭간에 데이터를 공유할 수 있으며, 한번 브라우저를 닫고 다시 방문할 때에는 데이터를 공유할 수 없다.**

1. 예 2. 아니오

정답 : 아니오\
해설 : 도메인이 같으면 페이지나 탭간에 데이터를 공유할 수 있으며, 한번 브라우저를 닫고 다시 방문할 때에도 데이터를 공유할 수 있습니다.

### Epilogue > Quiz

**Q1. 다음 세션 스토리지의 특징으로 잘못된 것은?**

1. 세션 스토리지는 도메인마다 각각 따로 생성된다.
2. 같은 도메인일 경우 하나의 세선스토리를 사용한다.
3. 윈도우 객체와 같은 유효범위와 저장 기간을 가진다.
4. 윈도우 복제로 생성된 경우, 스크립트를 이용해 새창을 연 경우 같은 값을 가진 세션 스토리지가 복사된다.

정답 : 2번\
해설 : 같은 도메인 경우라도 윈도우의 세션 스토리는 따로 생성된다.

**Q2. 세션 스토리지의 데이터 저장에 관한 설명으로 틀린 것은?**

1. 세션 스토리지 개체의 데이터 저장 방식은 키 값과 밸류(Key-Value Store)에서 문자열을 인덱스로 하는 방법으로 배열 형식과 같이 읽고 쓸 수 있다.
2. 데이터를 저장하는 경우, "setItem(Key, value)" 메소드를 호출하며 키(Key)값은 데이터를 저장하는 항목 이름, 값(value)은 해당 항목에 저장하는 데이터가 된다.
3. 같은 키의 항목이 이미 존재하는 경우, 중복값이 허용되지 않아 기존의 값은 null로 남고 새로운 값은 추가된다.
4. 문자열 이외의 값(value)을 지정하면 암시적으로 "Object.toString()" 메소드에 의해 문자열로 변환된 결과가 저장된다.

정답 : 3번\
해설 : 같은 키의 항목이 이밎 존재하는 경우, 기존 항목의 값이 새로운 값(value)으로 덮어 쓰게 되어 항목의 키가 중복되지 않는다.

**Q3. 로컬 스토리지의 설명 중 틀린 것은?**

1. 로컬 스토리지는 도메인마다 따로 생성된다.
2. 지속기간에 제한이 없으며 사용자가 리로드하게 되면 데이터는 소멸된다.
3. 도메인이 다르면 서로의 로컬 스토리지에 접근할 수 없다.
4. 같은 도메인에 각각의 웹 페이지는 모두 같은 로컬 스토리지를 가진다.

정답 : 2번\
해설 : 지속기간에 제한이 없으며 사용자가 명시적으로 지우지 않는 한 영구적으로 저장된다.

***

## 🐱‍🏍 11장. Web Database로 자료관리를 깔끔하게

### 🎯 Prologue > Pre-quiz

**Q1. Web SQL Database는 클라이언트 측에서 관계형 데이터베이스를 사용하기 위한 인터페이스 API이다.**

1. 예 2. 아니오

정답 : 예\
해설 : Web SQL Database는 클라이언트 측에서 관계형 데이터베이스를 사용하기 위한 인터페이스 API로 SQL을 이용한 유연한 데이터를 액세스할 수 있습니다.

**Q2. Web SQL Database의 주요 실행 구문은 데이터 베이스 오픈, 트랜잭션 시작, SQL 문장으로 실행하는 순서를 가진다.**

1. 예 2. 아니오

정답 : 예\
해설 : Web SQL Database의 주요 실행 구문은 openDatabase 메소드로 데이터 베이스 오픈, transaction 메소드로 트랜잭션 시작, executeSql 메ㅑ소드를 이용해서 SQL 문장을 실행하는 순서를 가집니다.

**Q3. Web SQL Database는 테이블을 만들거나 변경 처리를 쉽게 할 수 있는 장점을 가진다.**

1. 예 2. 아니오

정답 : 아니오\
해설 : Web SQL Database는 관계형 데이터베이스이므로 강력한 데이터 처리를 할 수 있는 장점을 가진 반면 테이블을 만들거나 변경처리를 쓰는 것이 복잡하다는 단점을 가집니다.

### Epilogue > Quiz

**Q1. Web SQL Database의 설명 중 틀린 것은?**

1. 스펙 상 Asynchronous/Synchronous( 비동기/동기) 두 가지 방식을 다 지원하지만, 현재 브라우저의 구현체들은 주로 Async 모델만을 지원한다.
2. 메소드의 리턴값으로는 적절한 객체나 결과를 얻을 수 없고, 콜백 함수를 메소드 인자로 전달한다.
3. Web 어플리케이션의 다양한 데이터를 저장하는 데 적합하다.
4. 키와 밸류로 데이터 객체를 인덱스로 관리한다.

정답 : 4번\
해설 : 키와 밸류 형과 같은 유용성을 가지면서, 검색 및 트랜잭션 기능을 데이터베이스는 "Indexed Database"이다.

**Q2. 다음은 인덱스 데이터베이스를 처음부터 검색하여 출력하는 구문이다. \_\_\_\_\_ 안에 들어갈 문장은 무엇인가?** var _**(A)**_ = evt.target.result if( _**(B) \_\_\_\_\_ ){ output.textContent += "\[id: " + cursor.key + "is " + cursor.value.ename + "]" cursor.**_ (C) \_\_\_\_\_() }

1. (A) cursor -> (B) cursor -> (C) continue
2. (A) cursor -> (B) next -> (C) return
3. (A) res -> (B) rs -> (C) return
4. (A) cursor -> (B) cursor -> (C) next

정답 : 1번\
해설 : 커서는 onsuccess의 콜백암수를 호출하는 구조를 가지며, 다음 레코드를 검색하려면, "this.result" 속성 값 (= 커서.IDBCursorWithValue 개체)의 continue 메소드를 호출하면 다음 레코드로 이동하게 된다.

**Q3. Indexed database의 설명 중 틀린 것은?**

1. Indexed Database는 클라이언트 측에서 NoSQL 기반 데이터베이스를 이용하기 위한 인터페이스 API이다.
2. Web SQL Database는 관계형 데이터베이스이므로 강력한 데이터 처리를 할 수 있는 점의 장점을 가진 반면, 테이블을 만들거나 변경 처리를 하는 단점을 가진다.
3. 키와 밸류 형과 같은 유용성을 가지면서, 검색 및 트랜잭션 기능을 가진 데이터베이스 API이다.
4. 하나의 데이터베이스에 여러 "ObjectStore"를 만들 수 있지만, JavaScript의 모든 객체를 저장할 수 없다.

정답 : 4번\
해설 : 하나의 데이터베이스에 여러 "ObjectStore"를 만들 수 있고, JavaScript의 모든 객체를 저장할 수 있다.

***

## 🐱‍🏍 12장. Web worker로 병렬처리 실현

### 🎯 Prologue > Pre-quiz

**Q1. HTML5에서 제공되는 Web Worker는 이전 버전의 불필요한 작업을 개선한 JavaScript를 포그라운드에서 스크립트 실행을 허용하는 기능으로 W#C에서 표준화가 진행되고 있다.**

1. 예 2. 아니오

정답 : 아니오\
해설 : HTML5에서 제공되는 Web Worker는 이전 버젼의 불필요한 작업을 개선한 JavaScript를 백그라운드에서 스크립트 실행을 허용하는 기능으로 W3C 표준화가 진행되고 있습니다.

**Q2. 워커 객체와 백그라운드 프로세서가 일대일로 대응하는 워커를 전용 워커(dedicated worker)라고 한다.**

1. 예 2. 아니오

정답 : 예\
해설 : 웹 워커의 종류에는 백그라운드 프로세서가 일대일로 대응하는 전용워커(dedicated worker)와 다수의 워커 객체에 의해 백그라운드 프로세스가 공유되는 공유워커(Shared worker) 두 종류가 있습니다.

**Q3. 쉐어드 워커에서 데이터를 송수신하려면 MessagePort 객체를 이용한다.**

1. 예 2. 아니오

정답 : 예\
해설 : 쉐어드 워커에서 데이터를 송수신하려면 MessagePort 객체를 이용하며 Message Port 개체는 연결된 두 인스턴스가 같은 송수신 채널을 사용합니다.

### Epilogue > Quiz

**Q1. 다음 두 개의 워커에서 같은 백그라운드를 사용하는 워커 코드가 아닌 것은?**

1. var worker1 = new SharedWorker( 'a.js' ); var worker2 = new SharedWorker ( 'a.js' );
2. var worker1 = new SharedWorker ( 'B.js' ); var worker2 = new SharedWorker ( 'B.js' );
3. var worker1 = new SharedWorker ( 'A.js', work1 ); var worker2 = new SharedWorker ( 'A.js', work2 );
4. var worker1 = new SharedWorker ( 'a.js' ); var worker2 = new SharedWorker ( 'b.js', worker1 );

정답 : 3번\
워커의 두 인스턴스는 이름이 다르기 때문에 각각 다른 워커에 연결된다.

**Q2. 워커객체인 worker.postMessage({ 'a' : 60 }) 메소드가 선언될 때 실행되는 과정 중 틀린 것은?**

1. 전용워커가 생성된 상태이므로 워커 객체와 프로세스 객체가 일대 일로 대응한다.
2. 워커가 실행되는 자바스크립트 코드에서 onmessage 이벤트 핸들러가 발생한다.
3. 에러가 발생되면 onerror에 이벤트 핸들러가 생성되어 객체가 콜백된다.
4. terminate() 메소드가 호출된다.

정답 : 4번\
해설 : terminate() 메소드는 워커를 강제로 종료하는 명시 호출되는 메서드이다.

**Q3. 다음 코드를 실행하게 되면 콘솔에 출력되는 내용은 무엇인가?**

```js
// worker01.html
var data = [ 1,2 ]
var worker = new Worker("worker2.js");
worker.onmessage = function(event) {
	console.log(event.data);
}
Worker.postMessage(data);

// worker2.js
onmessage = function(event) { 
	event.data.push(3);
	postMessage(event.data);
}
```

1. 1, 2
2. 1, 2, 3
3. 3
4. 3, 2, 1

정답 : 2번\
해설 : Push 메소드가 호출하게 되면 worker01.html에서 보내온 데이터의 끝에 3이 추가되고, 다시 포스트 메소드를 호출해서 보내기 때문에 1.2,3으로 출력된다.

***

## 🐱‍🏍 13장. 양방향 통신을 담당하는 Websocket

### 🎯 Prologue > Pre-quiz

**Q1. Ajax는 JavaScript의 XmlHttpRequest를 이용하여 서버와의 동기 통신을 실현하는 기능이다.**

1. 예 2. 아니오

정답 : 아니오\
해설 : Ajax는 JavaScript의 XmlHttpRequest를 이용하여 서버와의 비동기 통신을 실현하는 기능을 말합니다.

**Q2. comet는 서버 측에서 클라이언트에 응답을 반환하는 구조로 푸시(push) 기능을 제공하는 "롱 폴링" 방식을 사용 한다.**

1. 예 2. 아니오

정답 : 예\
해설 : comet는 Ajax의 단점인 브라우저의 요청으로 동작하는 구조가 아니라 서버 측에서 클라이언트에 응답을 반환하는 구조로 푸시(Push) 기능을 제공하는 "롤 폴링" 방식을 사용합니다.

**Q3. Websocket은 웹 서버와 브라우저가 직접 연결한 상태에서 양방향 통신을 위한 기술이다.**

1. 예 2. 아니오

정답 : 예\
해설 : Websocket은 Ajax나 Comet 통신의 단점을 보안한 기술로 웹 서버와 브라우저가 직접 연결한 상태에서 양방향 통신을 위한 기술입니다.

### Epilogue > Quiz

**Q1. Comet에 대한 기능으로 틀린 것은?**

1. Comet은 브라우저의 요청으로 동작하는 구조를 가진다.
2. HTTP의 틀 안에서 무리하게 푸시 기능을 제공하는 기술이며, HTTP 연결을 장시간 점유해 버리는 단점이 있다.
3. 제한 시간 만료 등은 매번 다시 연결해야 하므로 오버 헤드가 크다는 문제점을 가진다.
4. 리얼타임성이 중시되는 웹 응용프로그램에서는 오버헤드가 크다는 단점이 큰 걸림돌이 된다.

정답 : 1번\
해설 : COMET는 Ajax의 단점인 브라우저의 요청으로 동직하는 구조가 아니라 서버 측에서 클라이언트에 응답을 반환하는 구조로 푸시(Push) 기능을 제공하는 "롱 폴링" 방식을 사용한다.

**Q2. HTML5에서의 Websocket의 특징이 아닌 것은?**

1. 서버와 클라이언트간에 한번이라도 연결하면 데이터 교환을 socket 통신에서 실시할 수 있다.
2. Websocket에 연결하는 서버와 모든 클라이언트가 동일한 데이터를 공유하고 실시간으로 주고받을 수 있다.
3. HTML5 Websocket이 인터넷을 위한 단일 방식 통신 모델을 제공한다.
4. HTML5 Websocket은 단일 표준 인터페이스를 제공한다.

정답 : 3번\
해설 : HTML5 Websocket이 인터넷을 위한 전이중 방식 통신 모델을 제공함으로 예전의 방법론들이 초래하는 오버헤드 발생 없이 전혀 새로운 애플리케이션 모델 개발이 가능합니다.

**Q3. 다음중 Websocket의 요청 및 응답 헤더에서 사용하는 중요 포인트가 아닌 것은?**

1. Websocket의 대상을 지정하는 "Host"
2. Handshake 요청을 하기 위한 "Sec-Websocket-Key'
3. 클라이언트와의 연결을 유지하기 위한 "Sec-Websocket-Accept"
4. Websocket 버전을 지정하는 "Sec-Websocket-Version"

정답 : 2번\
해설 : Handshake 응답을 얻기 위한 "Sec-Websocket-Key"으로 Sec-Websocket-Accept 값을 만들어 리턴합니다.

***

## 🐱‍🏍 14장. 위치정보를 알아내는 Geolocation API

### 🎯 Prologue > Pre-quiz

**Q1. Geolocation API는 브라우저에서 단말기의 현재 위치가 되는 위도와 경도 등의 정보를 얻을 수 있는 API이다.**

1. 예 2. 아니오

정답 : 예\
해설 : Geolocation API는 브라우저에서 단말기의 현재 위치가 되는 위도와 경도는 물론이고 계속 위치를 모티터링하거나 연결을 끊을 수 있는 메소드들을 제공합니다.

**Q2. 보안 관점에서 Geolocation API 실행 시에 사용자의 권한이 필요하다.**

1. 예 2. 아니오

정답 : 예\
해설 : 보안 관점에서 Geolocation API 실행에 사용자의 권한이 필요하며 Geolocation API 실행시 브라우저는 사용자의 허가를 요청합니다.

**Q3. Geolocation API는 현재 위치와 그에 대한 정보를 제공하고 이동상태의 변동된 위치는 체크하지 못한다.**

1. 예 2. 아니오

정답 : 예\
해설 : Geolocation API에서 제공하는 watchPosition 메서드는 위치 정보를 모니터링하고, 위치가 변경될 때마다 위치 정보를 취득하고 싶은 경우에 이용하는 방법입니다.

### Epilogue > Quiz

**Q1. 현재 위치 정보를 구하는 상황에서 위치 정보 취득의 사용 허가가 나지 않아 오류로 호출된 콜백 함수에서 리턴되는 상수는 무엇인가?**

1. POSITION\_UNAVAILABLE
2. PERMISSION\_DENIED
3. PERMISSION\_DENIED\_TIMEOUT
4. PERMISSION\_ERROR

정답 : 2번\
해설 : PositionError 개체의 속성은 오류 코드 값을 가진 code라는 속성과 오류 메세지를 리턴하는 message라는 속성을 제공하며 정보취득의 사용 허가가 나질 않을 때의 상수는 PERMISSION\_DENIED로 리턴된다.

**Q2. watchPosition 메소드를 정의하여 현재 위치 정보를 모니터링 하려고 한다. 빈칸(A)에 들어갈 코드 중 틀린 코드는 무엇인가?** watchID = navigator.geolocation.watchPosition(successCallback, errorCallback, { _**(A)**_ })

1. enableHighAccuracy : true,
2. timeout : 1000,
3. maximumAge : 600000
4. maximumAge : 30000

정답 : 4번\
해설 : watchPosition과 getCurrentPosition의 매개 인자는 같이 사용되며 세번째 매개 인자의 옵션은 enableHighAccuracy, maximumAge, timeout이 제공된다.

**Q3. 지오로케이션 API에서 Position의 정보 취득을 할 때의 설명 중 틀린 것은?**

1. Position 취득이 성공했을 때의 콜백 함수는 Position 객체가 인수로 전달된다.
2. Position 속성에는 GPS 값을 정리한 Coordinates 객체가 저장되어 있는 coords가 있다.
3. Position 속성에는 타임 스탬프 값을 DOMTimeStamp로 저장되어 리턴하는 timestamp가 있다.
4. coords는 Position 객체에 속성이 포함되어 위도, 경도 등을 리턴한다.

정답 : 4번\
해설 : coords는 Coordinates 객체에 속성이 포함되어, 위도, 경도 등을 리턴한다.

***

## 🐱‍🏍 15장. 웹에서의 서버푸시 SSE(Server-Sent Events)

### 🎯 Prologue > Pre-quiz

**Q1. Server-Sent Events 실시간으로 전달하는 전용 텍스트 데이터를 서버와 클라이언트 사이에서 통신하도록 하는 기능을 말한다.**

1. 예 2. 아니오

정답 : 예\
해설 : Server-Sent Events는 실시간으로 전달하는 전용 텍스트 데이터에 의해 이벤트 스트림을 브라우저의 백그라운드에서 서버와 클라이언트 사이에서 통신합니다.

**Q2. Server-Sent Events 서버가 데이터를 분할하여 전송하는 것을 나타내는 HTTPS "Transfer-Encoding : chunked" 형식을 가진다.**

1. 예 2. 아니오

정답 : 예\
해설 : 서버가 데이터를 분할하여 전송하는 것을 나타내는 HTTP의 "Transfer-Encoding : chunked" 형식으로 이벤트 스트림을 보낼 경우 이 데이터는 클라이언트에 실시간 순차적으로 보내져 클라이언트 측 분석도 연결이 닫힘 때까지 기다리지 않고 실시간으로 응답이 이루어집니다.

**Q3. JSON이란 JavaScript Object Notation의 약자로 "제이슨"이라고 하며 이미지들만 전용으로 압축해서 객체로 생성해서 관리하는 스크립트이다.**

1. 예 2. 아니오

정답 : 아니오\
해설 : JSON이란 JavaScript Object Notation의 약자로 "제이슨"이라고 하며 JSON은 숫자나 문자열이, 배열 및 객체의 데이터를 문자열로 표현할 수 있는 가벼운 형식을 제공합니다.

### Epilogue > Quiz

**Q1. SSE(Sever Sent Events)의 설명 중 틀린 것은 무엇인가?**

1. 서버에서 필요한 정보가 들어오는 PUSH 전송을 가능하게 해주는 것이 "Server-Sent Events"라는 기능이다.
2. Server-Sent Events는 실시간으로 전달하는 전용 텍스트 데이타에 의해 이벤트 스트림을 브라우저의 백그라운드에서 서버와 클라이언트 사이에서 통신한다.
3. 이벤트 스트림은 클라이언트의 요청에 대해 서버가 연결된 상태에서 데이터를 즉시 일괄 처리한다.
4. 서버가 데이터를 분할하여 전송하는 것을 나타내는 HTTP의 "Transfer-Encoding : chunked" 형식을 가진다.

정답 : 3번\
해설 : 이벤트 스트림은 클라이언트의 요청에 대해 데이터를 즉시 처리하지 않고 연결 상태에서 필요한 만큼 유지되고 서버에서 이벤트가 발생할 때마다 그 요청한 데이터가 추가되어 리턴된다.

**Q2. SSE(Server Sent Events)의 클라이언트 측의 구현할 코드에 대한 설명 중 틀린 것은?**

1. EventSource 객체를 연결할 URL을 지정하고 인스턴스화하면, 서버 측 이벤트 수신 백그라운드에서 자동으로 시작된다.
2. 서버 측에서 이벤트가 발생하면 동일한 이름의 이벤트가 EventSource 객체에서 실시간으로 발생된다.
3. 이벤트의 종류는 서버 측에서 자유롭게 정의 및 지정할 수 있지만 지정이 없는 경우는 "message" 이벤트로 처리된다
4. Server-Sent Events는 도메인 간의 통신이 자유로워 HTML 파일은 도메인이 다른 곳에 있어도 서버와의 원활하게 통신이 가능하다.

정답 : 4번\
해설 : Server-Sent Events는 도메인 간 통신은 허용되지 않아 서버와 통신하는 코드가 작성된 HTML파일은 대상과 동일한 도메인의 URL에 포함되어 있어야 한다.

**Q3. JSON에 대한 설명 중 틀린 것은 무엇인가?**

1. JSON이란 Javascript Object Notation의 약자로 "제이슨"이라고 한다.
2. JSON은 숫자 및 문자열이나 배열 및 개체의 데이터를 문자열로 표현할 수 있는 가벼운 형식을 제공한다.
3. JavaScript의 객체와 문자열과의 상호 변환을 쉽게 다룰 수 있는 장점이 있다.
4. JSON을 작성하는 형식은 XML과 같이 유저에 의해 자유롭게 커스텀 형식을 생성해서 사용한다.

정답 : 4번\
해설 : JSON을 작성하는 형식은 문자열을 다루는 형식의 포맷이 정해져 있으며 문자열을 선언할 때 ":"를 사용한 키와 값의 쌍을 이루는 구조에서, 키에는 항시 ""(겹따옴표)를 사용해야 한다.

***

## 🐱‍🏍 16장. CORS를 구현하는 XHR2

### 🎯 Prologue > Pre-quiz

**Q1. JavaScriptS 사용하면 "비동기 데이터 송수신"을 할 수 있으며 "HTML 내용을 동적으로 변경" 할 수 있다.**

1. 예 2. 아니오

정답 : 예\
해설 : JavaScript를 사용하면 "비동기 데이터 송수신"을 할 수 있으며 "HTML의 내용을 동적으로 변경" 할 수 있으며 "비동기 통신"과 "다이나믹 HTML" 두 기술을 조합한 것을 Ajax라고 합니다.

**Q2. XMLHttpRequest(XHR)는 Ajax의 기본 구성 요소 중 하나로 동기화 데이터 통신을 유도한다.**

1. 예 2. 아니오

정답 : 아니오\
해설 : XMLHttpRequest(XHR)는 Ajax의 기본 구성 요소 중의 하나로 비동기 데이터 통신을 실현하기 위한 API로 브라우저에서 서버와 HTTP 통신을 위한 API입니다.

**Q3. XHR2란 HIML5에서 제공되는 타 도메인 간 자원 공유 CORS(Cross Oragin Resource Sharing)를 할 수 있는 객체이다.**

1. 예 2. 아니오

정답 : 예\
해설 : XHR2란 "XMLHttpRequest Level2"의 약자로 HTML5에서 제공되는 타 도메인 간 자원 공유 CORS(Cross Oragin Resource Sharing)를 할 수 있는 객체입니다.

### Epilogue > Quiz

오늘 비운 내용을 퀴즈를 동해 정리해 보세요.

**Q1. 다음 중 XMLHttpRequest의 설명 중 틀린 것은?**

1. XMLHttpRequest(XHR)는 Ajax의 기본 구성 요소 중의 하나로 비동기 데이터 통신을 실현하기위한 API이다.
2. 데이터 통신 시 XML에 한정되어 있어 속도가 빠르고 견고하지만 전송시 데이터 통신의 타입에 제한을 받는 것이 단점이다.
3. 원래는 "Internet Explorer 5"에서 "ActiveX 객체"로 구현했지만, 다른 브라우저에서도 호환 동등한 기능 구현을 비롯해 XMLHttpRequest로 사용할 수 있다.
4. XMLHttpRequest는 원래는 IE 5에서 ActivexObject의 Microsoft.XMLHTTP 구성 요소로 시작되었다

정답 : 2번\
해설 : XML에 한정된 것이 아니라, HTTP를 통해 클라이언트가 요청을 할 때 텍스트 또는 DOM 노드에서 응답을 받는 기능을 가지고 있습니다.

**Q2. 다음 중 XMLHttpRequest의 open(method, url, asynch, username, password) 메소드의 매개인자 설명 중 틀린 것은?**

1. 매개인자 중에서 method, 1411은 필수 항목으로 반드시 명시해야 한다.
2. method는 POST, GET, PUT 중 하나를 지정하며 url은 요청하고자 하는 서버의 url을 명시한다.
3. asynch는 요청이 비동기인지 여부를 true, false로 지정하며 디폴트로 false가 설정되어 요청은 비동기로 처리된다.
4. 마지막 매개인자인 암호 지정은 인증이 필요한 경우 암호로 지정한다.

정답 : 3번\
해설 : asynch는 요청이 비동기인지 여부를 true, false 지정하며 false로 설정하면 요청은 동기로 처리되기 때문에 서버에서 응답을 받을 때까지 프로세스는 기다리게 됩니다.

**Q3. XMLHttpRequest의 send( )메소드의 설명 중 틀린 것은?**

1. 데이터의 송수신을 시작하려면, send( )메서드를 사용한다.
2. 보낼 데이터가 있는 경우, 매개인자로 문자열을 지정하고 보낼 데이터가 없는 수신만 한 경우에는 null를 지정한다.
3. 브라우저가 "XMLHttpRequest Level2"에 해당하는 경우 Document 객체만 지정할 수 있다.
4. GET 메소드를 지정하면 send( ) 메소드의 인수에 null을 지정하여 open( ) 메소드가 액세스 URL 문자열로 보낼 데이터를 지정한다.

정답 : 3번\
해설 : 브라우저가 "XMLHttpRequest Level2"에 해당하는 FormData 개체, ArrayBuffer 개체, Blob 객체, Document 객체 등을 지정할 수 있다.

***

## 🐱‍🏍 17장. 화려한 시각을 자랑하는 CSS3

### 🎯Prologue > Pre-quiz

**Q1.CSS3 사양 권고(Recommendation)된 것은 아직 일부이지만, 각 브라우저에서는 모든 기능을 지원하고 있다.**

1. 예 2. 아니오

정답 : 아니오\
해설 : CSS3 사양 권고(Recommendation)된 것은 아직 일부이지만, 각 브라우저에서는 일부 지능을 지원하고 있어 선택하기 전에 각 브라우저마다 다른 접두사(profix)를 넣어 해상 벤더사에 맞게끔 지정해야 합니다.

**Q2. CSS(Cascading style Sheets)는 웹 페이지의 디자인을 정의하는 언어로 스타일 시트라고 하며 CSS(Cascading style Sheets Level 3)은 CSS의 새로운 사양으로 버전업이 된 명칭이다.**

1. 예 2. 아니오

정답 : 예\
해설 : CSS3(Cascading Style Sheet level 3)은 CSS의 새로운 사양으로 글꼴이나 텍스트, 이미지 등의 모듈로 나누어져 있으며, 에니페이션 효과나 입력 내용 검사 기능이 추가되었고 Web 서버에서 글꼴을 다운로드하고 브라우저에서 표시할 수 있습니다.

**Q3. Box-shadow 속성을 지정하면 상자에 그림자 효과를 줄 수 잇으나 상자의 모양은 변경할 수 없다.**

1. 예 2. 아니오

정답 : 아니오\
해설 : Box-shadow 속성을 지정하면 상자에 그림자 효과를 줄 수 있으며 둥근 효과를 선택한 경우, 그림자 모서리도 둥글게 됩니다.

### Epilogue > Quiz

**Q1. 다음 코드의 설명 중 맞는 것은?** #box2{ box-shadow: 0.5em 0.5em blue, red -0.5em 0.7em 5px; }

1. 상자 오른쪽 아래 푸른색 그림자와 왼쪽 아래 수직으로 빨간색 그림자 지정
2. 상자 왼쪽 아래 빨간색 그림자와 왼쪽 아래 수직으로 빨간색 그림자 지정
3. 상자 오른쪽 아래 빨간색 그림자와 왼쪽 아래 수평으로 파란색 그림자 지정
4. 상자 왼족 아래 푸른색 그림자와 왼쪽 아래 수평으로 빨간색 그림자 지정

정답 : 1번\
해설 : box-shadows 상자의 그림자를 지정하는 속성으로 해당 지정된 위치에 첫 번째 길이의 값은 수평 그림자의 오프셋 거리이며 양수값을 지정하면 오른쪽으로, 음수값을 지정하면 왼쪽으로 그림자가 이동합니다. 두 번째 길이의 값은 빨간색 칼라로 수직 그림자의 오프셋 거라이며, 약수값을 지정하면 아래로 음수값을 지정하면 위로 그림자가 이동합니다.

**Q2. 원형 그라데이션 속성의 크기 중 틀린 것은?**

1. closest-side contain : 그라데이션이 중심점에서 가장 먼 가장자리에 접하는 크기
2. farthest-side : 그라데이션이 중심점에서 가장 먼 가장자리에 접하는 크기
3. closest-corner : 그라데이션이 중심점에서 가장 가까운 모서리에 접하는 크기
4. farthest-corner cover : 그라데이션이 중심점에서 가장 먼 모서리에 접하는 크기

정답 : 1번\
해설 : Closest-side contain은 그라이데이션이 중심점에서 가장 가까운 근처에 내접하는 크기를 지정합니다.

**Q3. 자식 요소에 스타일을 적용하는 방법 중 틀린 것은?**

1. first-child 선택자는 지정된 요소가 자식 요소 중에서 첫 번째 위치에 오는 요소를 대상으로 스타일을 적용한다.
2. first-of-type 선택자는 자식 요소 내용 중 자식 요소의 개수에 상관없이 첫 번째 타입이 맞는 요소가 있다면 스타일이 적용된다.
3. last-child 선택자는 자식으로 마지막 위치에 있는 요소 하나만 스타일을 적용할 때 사용한다.
4. only-child의 경우 지정된 요소가 맞는 자식 요소의 수가 1개 뿐인 경우에 스타일이 적용된다.

정답 : 2번 해설 : first-of-type 선택자는 자식요소 내용 중 첫 번째 타입이 맞는 요소 하나만 스타일이 적용 됩니다.

***

## 🐱‍🏍 18장. 스타일리쉬한 그래픽 CSS3

### 🎯 Prologue > Pre-quiz

**Q1. CSS3의 transform 속성은 요소에 2D 변형 또는 3D 변형을 적용할 때 사용한다.**

1. 예 2. 아니오

정답 : 예\
해설 : CSS3의 transform 속성은 요소에 2D 변형 또는 3D 변형을 적응할 때 사용하며 transform 속성값에 포함되어 있는 transform 함수를 지정하면 요소 매트릭스 변형, 이동, 축척, 회전, 기울이기 등의 변형을 적용할 수 있습니다.

**Q2. translate(x, y) 메소드는 도형을 세로 축과 가로 축에 지정된 이동 거리만큼 평행 이동한다.**

1. 예 2. 아니오

정답 : 예\
해설 : translate(x, y) 메소드는 도형을 세로축과 가로촉에 지정된 이동 거리만큼 평행 이동하며 translate(가로 이동 거리, 세로 이동 거리)는 matrix(1, 0, 0, 1, 옆의 이동 거리, 세로 이동 거리)와 같습니다.

**Q3. scale() 메소드는 도형을 세로 축과 가로 축에 지정된 배율대로 기울기를 한다.**

1. 예 2. 아니오

정답 : 아니오\
해설 : scale() 메소드는 도형을 세로축과 가로축에 지정된 배율만 확대 축소시키며 배울이 0보다 크고 1보다 작은 소수이면 축소됩니다.

### Epilogue > Quiz

**Q1. translate() 메소드에 대한 설명 중 틀린 것은?**

1. 도형을 세로축과 가로축에 지정된 이동 거리만큼 평행 이동한다.
2. translate( )에서 수직 이동 거리가 생략된 경우, 0이 지정된 것이다.
3. translate(가로 이동 거리, 세로 이동 거리)는 matrix(1, 0, 0, 1, 가로의 이동 거리, 세로 이동 거리)와 같다.
4. 도형을 세로축과 가로축에 지정된 배율만 확대 축소시키며 배율이 0보다 크고 1보다 작은 소수이면 축소된다.

정답 : 4번 해설 : 도형을 세로축과 가로축에 지정된 배율만 확대·축소시키며, 배율이 0보다 크고 1보다 작은 소수이면 축소되는 것은 scale()에 대한 설명이다.

**Q2. transition 속성에 대한 설명으로 틀린 것은?**

1. tansition-property 속성은 전환 대상 속성 이름을 지정한다.
2. transition-duration 속성은 원래 값에서 새로운 값이 될 때까지 걸리는 시간을 지정한다
3. transition-timing-function 속성은 경과 시간에 변화의 방법을 지정한다.
4. transition-delay 속성은 지정된 시간 만큼 변화를 멈추었다가 실행된다.

정답 : 4번 해설 : transition-delay 속성은 변화가 시작될 때까지의 시간을 지정합니다.

**Q3. 다음은 무슨 메소드에 관한 설명인가?** 투시도법에 의한 원근감효과를 추가하는 메소드로 시점 위치와 화면 위치 사이의 거리를 인수 "관점 거리"로 지정하며 관점의 평면에서의 위치는 요소의 중심점이다. 관점이 적용되는 요소에 대해 설정되므로 여러 요소를 같은 원근에 그리는 경우에는 부모 요소에서 지정되어야 한다.

1. sale()
2. translate()
3. rotate()
4. perspective()

정답 : 4번\
해설 : perspective()는 투시도법에 의한 원근감 효과를 추가하는 메소드로 먼 것은 작게 그리고, 시점에 가까운 것은 크게 그려집니다.

***

## 🐱‍🏍 19장. Javascript의 라이브러리 jQuery

### 🎯 Prologue > Pre-quiz

**Q1. 제이 쿼리(jQuery)란 경량의 javaScript 라이브러리이다.**

1. 예 2. 아니오

정답 : 예\
해설 : 제이 쿼리(jQuery)란 Firefox의 JavaScript 책임자를 맡고 있던 John Resig이 2006년 1월에 발표한 경량의 javascript 라이브러리입니다.

**Q2. jQuery의 기능은 DOM 엘리먼트 선택, DOM 트래버설 및 수정, 이벤트, CSS 조작, 특수효과 및 애니메이션, Ajax 확장성, 유틸리티 및 자바스크립트 플러그인 등이 있다.**

1. 예 2. 아니오

정답 : 예\
해설 : 브라우저에 의존하지 않는 크로스 브라우저 동작과 함께 가벼운 jQuery 본체 외에 jQuery의 기능을 더욱 확장 해주는 풍부한 "플러그인"과 "jQuery Ul"도 제공됩니다.

**Q3. jQuery의 셀렉터로 HTML의 요소에 접근하는 방법은 요소의 아이디와 클래스로 접근하는 2가지 방법이 존재한다.**

1. 예 2. 아니오

정답 : 아니오\
해설 : jQuery의 셀렉터로 HTML의 요소에 접근하는 방법은 문서에 액세스, 특정 클래스를 가진 요소에 액세스, 특정 요소에 액세스, 계층 구조에 액세스 등이 있습니다.

### Epilogue > Quiz

**Q1. jQuery 속성 선택기에 대한 설명으로 틀린 것은?**

1. $("\[href]")는 href 속성을 가진 모든 요소를 선택한다.
2. $("\[href = '#']")는 href id="#"을 가진 모든 요소를 선택한다.
3. $("\[href != '#']")는 href 속성이 "#"와 동일하지 않은 모든 요소를 선택한다.
4. $("\[href $='.jpg']")는 'jpg'로 끝나는 href 속성을 가진 모든 요소를 선택한다.

정답 : 2번 해설 : $("\[href = '#']")는 href value = "#"을 가진 모든 요소를 선택한다.

**Q2. 다음 중 슬라이더를 구현하는 메소드가 아닌 것은?**

1. $(selector).slideDown(speed, callback)
2. $(selector).slideUp(speed, callback)
3. $(selector).slideMove(speed, callback)
4. $(selector).slideToggle(speed, callback)

정답 : 3번\
해설 : jQuery 슬라이드 함수는 slideDown, slideup, slideToggle 세가지를 제공한다.

**Q3. 다음 구문 설명 중 틀린 것은?**

1. $(this).hide() - 전체 폼의 요쇼를 숨긴다.
2. $("p").hide() - P 요소를 숨긴다.
3. $("p.test").hide( ) - p요소의 test 클래스인 요소를 숨긴다.
4. $("#test").hide( ) - id가 "test"인 요소를 숨긴다.

정답 : 1번\
해설 : $(this).hide( )는 this 객체에 의해 현재 요소를 숨긴다.

***

## 🐱‍🏍 20장. HTML5 WebStyling 프로젝트

### 🎯 Prologue > Pre-quiz

**Q1. jQuery Ul는 jQuery로 만들어진 라이브러리로 웹 표현 작업을 하는데 필요한 기능을 제공해 준다.**

1. 예 2. 아니오

정답 : 예\
해설 : jQuery Ul는 jQuery로 만들어진 라이브러리로, 애니메이션, 향상된 효과, 다양한 위젯 등 페이지에서 작업을 하는데 필요한 기능을 제공해 줍니다.

**Q2. jQuery Plugin 공식 사이트에서는 애니메이션 효과나 양식 작업 보조 미디어 작업 등 수천개의 플러그인이 공개되어 있으며 개발자가 만든 플러그인을 등록할 수 없다.**

1. 예 2. 아니오

정답 : 예\
해설 : jQuery Plugin 공식 사이트에서는 애니메이션 효과나 양식 작업 보조 미디어 작업 등 수천개 이상의 플러그인이 공개되어 있으며 개발자가 만든 플러그인을 등록할 수 있습니다.

**Q3. jQuery의 기능을 확장하여 마우스 조작 및 애니메이션 기능 등 사용자 인터페이스에 특화한 라이브러리를 jQuery UI라고 한다.**

1. 예 2. 아니오

정답 : 예\
해설 : jQuery의 기능을 확장하여 마우스 조작 및 애니메이션 기능 등 사용자 인터페이스에 특화한 라이브러리인 jQuery UI가 있으며 다양한 API를 제공합니다.

### Epilogue > Quiz

**Q1. 다음 코드의 설명 중 틀린 것은 무엇인가?** 예문)

```js
$("#droppable").droppable({
	drop : function(event, ui){
		$(this).addClass("ui-state-highlight").find("p").html("드롭되었습니다")
	}
})
```

1. id가 droppable인 대상을 찾아 드롭하는 상태를 구현한 코드이다.
2. 드롭할 때 발생하는 이벤트를 이용해서 스타일 시트인 "ui-state-highlight"을 적용한다.
3. 선택 대상을 드롭할 때 클래스가 P인 요소를 찾아 "드롭되었습니다"를 출력한다.
4. addClass("ui-state-highlight")는 스타일을 추가하는 메소드이다.

정답 : 3번\
해설 : 선택 대상을 드롭할 때 클래스가 아닌 P요소를 찾아 "드롭되엇습니다"를 출력합니다.

**Q2. 다음 중 jQuery UI 중 Interaction의 설명이 아닌 것은 무엇인가?**

1. Draggable : 지정된 요소를 마우스로 이동한다.
2. Droppable : 지정된 요소를 드롭한다.
3. Mouse : Interaction (상호 작용)의 기본 기능을 제공한다.
4. Focusable : 초점을 맞출 수 있는 요소를 선택한다.

정답 : 4번\
해설 : focusable UI 선택을 구현하는 Selector에 속합니다.







